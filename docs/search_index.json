[["index.html", "Introdução ao R 1 Boas vindas", " Introdução ao R Raimundo Marciano de Freitas Neto 2022-03-21 1 Boas vindas O curso será composto por módulos teóricos e práticos e terá duração de XX horas, distribuídas em XX semanas, conforme o seguinte cronograma: S01 00-00 a 00-00 Dados e funções S02 00-00 a 00-00 Importação de Dados e Formas de Coleta S03 00-00 a 00-00 Relatórios O curso é essencialmente assíncrono e a frequência será registrada de acordo com a entrega das atividades nos prazos assinalados. Nas XX-feiras, das XXh às XXhXX, teremos um encontro síncrono para dúvidas via Google Meet. "],["intro.html", "2 O que é o R? 2.1 Instalando o R 2.2 R Studio 2.3 R nas Nuvens 2.4 Scripts 2.5 Exercício 2.6 Gabarito Exercício", " 2 O que é o R? R é uma linguagem de programação muito utilizada para o desenvolvimento de estatísticas e cálculos matemáticos. Entretanto, enquanto linguagem de programação, ela possui muitos usos, como a raspagem de sites, a automatização de download de arquivos, e a produção de dashboards e relatórios, sendo útil para a coleta de dados e para o reporte das análises, além de ser gratuita. Mas o que significa ser uma linguagem de programação? Basicamente, você irá dar ordens ao computador por meio de comandos. A vantagem de aprender a estruturar os comandos (ao invés de usar um programa estatístico já consolidado, como o Stata) é que você pode customizar a vontade suas análises. Os programas estatísticos trazem muitas opções pré-prontas. Por exemplo, no Stata é comum que você possa clicar em uma janela e solicitar um quadro com as estatísticas descritivas (média, moda, mediana) de um banco de dados. Entretanto, qualquer funcionalidade fora do padrão oferecido por aqueles pacotes precisará ser gerada pelo próprio usuário (e quando você usa algum recurso como o ssc install é porque alguém gastou um tempinho fazendo isso). Aliás, o Python (outra linguagem de programação) possui funcionalidades bem similares ao R, embora o modo de escrever os programas seja bem diferente. Imagine que o Português e o Espanhol têm o mesmo propósito - a comunicação - e que mesmo tendo uma mesma raiz (e inclusive diversos vocábulos bem parecidos), possuem algumas regras estruturais bem diferentes, o que inclui, por exemplo, as regras de acentuação e o som produzidos pelas letras: qual a diferença de cajá (PT-BR) para caja (ES); qual a diferença de pastel (PT-BR) para pastel (ES)? É preferível que o analista iniciante dedique-se a uma das duas (R ou Python). Posteriormente, aprender a outra (ou mais alguma que esteja despontando no mercado, como a Julia) será uma tarefa bem mais simples. Isso se deve ao fato de que diversos elementos da programação se repetem entre as diferentes linguagens, especialmente os conceitos. Um IF tem o mesmo propósito em R ou em Python ou em Java ou em C++, embora a forma como você deve explicar ao computador o que fazer com esse IF será bem diferente em cada linguagem. 2.1 Instalando o R O R é instalado como um programa normal. Primeiro, você deve acessar a página do R Project. Há vários links para baixar. Todos funcionam e disponibilizam os mesmos arquivos, mas sugere-se clicar no local mais próximo ao que você se encontra. Na nova página, clique em Download R for Windows. Depois, clique em base. Caso você queira baixar a versão mais recente, clique em Download R xxx for Windows. Caso você prefira uma versão mais antiga, clique em Previous releases (fica um pouco abaixo, na seção Other Builds). Alternativamente, clique aqui. Aparência do R-GUI Na parte superior, é possível visualizar a versão do R que está sendo executada. Nem sempre é interessante, para o programador novato, usar a última versão disponível, porque ela ainda pode conter alguns bugs. Por isso, mesmo que a versão mais atual seja a 4.0.4, pode ser interessante nos mantermos na 4.0.3 ou até mesmo na 3.6.3. Na linha iniciada por \\(&gt;\\) podemos dar instruções ao R. Por exemplo, digite 1+1 e depois aperte ENTER. 1+1 ## [1] 2 O R executou a soma solicitada e retornou o resultado. 2.2 R Studio O R Studio é um programa que permite trabalhar o R de forma aprimorada. Ele é o que os desenvolvedores chamada de Ambiente Integrado de Desenvolvimento (ou Integrated Development Environment (IDE), no original). Já tendo instalado o R, que fornece a base da linguagem de programação e a interface básica com o computador, podemos agora instalar o R Studio. Primeiramente acesse o site do R Studio. Embora existam versões pagas com recursos interessantes, todos os recursos necessários ao programador iniciante estão incluídos na versão gratuita. Clique no botão DOWNLOAD R STUDIO FOR WINDOWS. Depois do download concluído, instale o programa na sua máquina normalmente. O R Studio automaticamente identifica o R-base instalado na sua máquina (é realmente necessário já ter instalado o R antes!). O RStudio O RStudio tem quatro áreas relevantes. Na parte superior esquerda, ficam os scripts; na parte inferior esquerda, o console; na parte superior direita, o ambiente; no parte inferior direita, os diretórios, gráficos, pacotes, e a ajuda. O script é um arquivo com um roteiro. Você não é obrigado a usar um script, mas é muito útil usá-lo, porque pode ser interessante que você retome o trabalho posteriormente. Você começa a preparar um roteiro em um dia e, posteriormente, continua a escrevê-lo, ou a ajustá-lo. Nesses roteiros, há linhas de código (comandos que o R executará) e linhas de comentários (texto que o R deve ignorar, mas que é muito útil para os humanos que estão lendo o script). Os comentários podem servir para dividir o roteiro em seções, informando que as linhas de código seguintes tem tal utilidade; ou para lembrar o próprio programador de algo, como o que ele ainda precisa fazer ou que tipo de informação aquele código irá produzir. É uma boa prática de programação incluir comentários no código. Lembre-se que se você precisar ver novamente seu código depois de um tempo, você pode não lembrar bem de várias coisas que você tinha em mente quando o estava escrevendo. Por exemplo, se você está escrevendo um código para uma disciplina de um curso, pode ser que você precise meses depois desse mesmo código. Será que você lembrará de tudo o que é necessário? No Console, você pode passar informações para o R que não foram incorporadas ao Script. ÀS vezes você quer ficar testando algum procedimento, até encontrar a solução correta para um problema, podendo ser útil fazer isso direto no Console, para depois incluí-la no Script. Ambiente Global do RStudio Na linha iniciada por um &gt; podemos digitar comandos. Uma das principais vantagens do R Studio é que facilita o acompanhamento das informações que estão sendo trabalhadas. Essa IDE exibe, no painel lateral, os bancos de dados que estão ativos, as variáveis que foram salvas e as funções criadas pelo próprio usuário. Ambiente Global do RStudio Como o programa acabou de ser aberto pela primeira vez, ainda não tem nada na memória. Entretanto, se você digitar no Console mensagem = Olá Mundo E pressionar ENTER no teclado, aparecerá no Environment a informação de que há uma mensagem cujo conteúdo é Olá Mundo. Essa informação pode ser tratada posteriormente. Por enquanto, digite: x = 1 E agora perceba que há um x que contém o valor 1. É possível modificar o conteúdo desse x. x = x + 1 Estamos pedindo que o R some ao X o número 1; em outras palavras, o x agora é igual ao que já havia no próprio x mais 1. Obviamente, o resultado é 2. No environment é possível checar isso. Para ver isso no Console, digite apenas x E o console exibirá o conteúdo desse x, o número 2. Outros menus 2.3 R nas Nuvens O R Studio Cloud permite que você use o R Studio sem precisar instalá-lo na sua máquina. Para o usuário iniciante com uma conta gratuita, a principal limitação é a do tempo de uso, que é de 25 horas mensais. Por isso, essa pode ser uma opção circunstancialmente viável (você pode estar em um computador diferente do que você habitualmente utiliza), mas normalmente é recomendável que você instale os programas no seu computador e rode localmente os códigos. De toda forma, é sempre útil conhecer essa opção, criando uma conta gratuita em https://rstudio.cloud/. 2.4 Scripts Algumas informações adicionais sobre os scripts. O arquivo de script funciona como um roteiro e deve conter dois tipos de informações: linhas de código e linhas de comentário. As linhas de código são aquelas que o R irá ler, interpretar e executar; ou seja, produzirão algum efeito. Pode-se usar linhas de código para gravar informações na memória do sistema, trazendo os dados contidos em um arquivo ou declarando o conteúdo de uma variável (x = 1 significa que há uma variável x cujo conteúdo é o número 1). Também são usadas para transformar o que está contido na memória, e para gerar saídas, como a criação de arquivos cujo conteúdo são os objetos que estão armazenados na memória (depois que você importou para o R os dados das vendas, você produziu os relatórios, transformando os dados em informação útil e por fim disponibilizou essa informação em algum modo mais acessível a pessoas que não usam o R, como um .pdf) As linhas de comentário são utilizadas para descrever o código, sem que isso represente um detalhamento. A ideia é que haja informações que ajudem a esclarecer o que está acontecendo. Se seu script possui apenas duas linhas de código, você pode incluir apenas uma linha de comentário informando o objetivo daquela rotina. Entretanto, conforme o script vai crescendo e atinge algumas centenas ou milhares de linhas de código torna-se imprescindível que haja mais linhas de comentário. Elas ajudam a separar as funcionalidades (esse primeiro bloco é usado para a importação de dados; o segundo, para ver se os dados estão corretos; o terceiro, para o tratamento; e assim por diante); a indicar que tipos de dados são esperados nas funções; que tipo de saída será produzida; o que aquele pedaço de código realmente faz. As linhas de comentário devem começar com um # (jogo da velha ou cerquilha). Essas linhas são ignoradas, não surtindo efeito sobre o que está sendo desenvolvido. # Essa é uma linha de comentário 1+1 # os comentários também podem vir imediatamente após o código ## [1] 2 Às vezes, temos a intenção de fazer com que um bloco (conjunto) de linhas de código seja ignorado. Isso geralmente acontece quando estamos escrevendo um programa e queremos testar diferentes possibilidades. Uma forma simples de fazer isso sem apagar aquele bloco é deixando-o comentado, ou seja, fazendo com que todas as suas linhas sejam iniciadas por um #. No R Studio, isso pode ser feito convenientemente: selecione o bloco que você pretende deixar comentado e aperte Ctrl + Shift + C. Se você usa um sistema operacional diferente do Windows, a tecla de atalho pode ser outra. # Essa é uma linha de comentário #1+1 # essa linha não será executada 2+2 # apenas essa linha produzirá efeito ## [1] 4 2.5 Exercício Copie o seguinte texto pro Script do R Studio. meu_primeiro_objeto = &quot;Hello World&quot; # Há uma tradição entre programadores de que você deve incluir na primeira lição # sobre uma linguagem de programação o print do Hello World. Esse comando faz com que # Seja exibida a mensagem &quot;Hello World&quot; (Olá Mundo). Não fazer isso dá azar. print(meu_primeiro_objeto) taxa = 0.05 valor_presente = 1000 tempo = 10 valor_futuro = valor_presente*(1+taxa)^tempo mensagem = paste(&quot;O valor futuro do empréstimo é&quot;, valor_futuro) print(mensagem) Selecione a primeira linha e clique em Run. O que aconteceu com o Global Environment e com o Console? Selecione a segunda linha e clique em Run. O que aconteceu com o Global Environment e com o Console? Clique no botão Source. O que aconteceu com o Global Environment e com o Console? 2.6 Gabarito Exercício Selecione a primeira linha e clique em Run. O que aconteceu com o Global Environment e com o Console? O R cria um objeto contendo Hello World e temporariamente o grava na memória. Esse objeto aparece no Global Environment. No Console, aparece o comando que foi dado. Selecione a segunda linha e clique em Run. O que aconteceu com o Global Environment e com o Console? A segunda linha é iniciada por um #, o que significa que é uma linha de comentário. O R irá levá-la para o Console, mas não a executará (justamente porque é um comentário). Então irá tentar executar a terceira linha. Como também é um comentário, será registrada no Console, mas sem qualquer efeito. O mesmo vale para a quarta linha. A quinta linha contém código, solicitando que o comando print(meu_primeiro_objeto) seja executado. Esse comando será registrado no Console; o R irá ler o conteúdo do objeto meu_primeiro_objeto e exibirá seu conteúdo: Hello World. Clique no botão Source. O que aconteceu com o Global Environment e com o Console? Todo o script é lido; e todas as linhas de código, executadas. São temporariamente armazenados na memória, além do meu_primeiro_objeto, a taxa, o tempo, o valor_presente, o valor_futuro (no caso, o resultado do cálculo proposto) e a mensagem. NO console aparecem todas as linhas lidas e é exibido o conteúdo do objeto mensagem: O valor futuro do empréstimo é 1628.89462677744. "],["variáveis.html", "3 Variáveis 3.1 Numéricas 3.2 Textuais 3.3 Lógicas 3.4 Datas 3.5 Exercício", " 3 Variáveis Os dados podem ser importados (trazidos de um arquivo para o R) ou digitados no próprio console. Quando você deseja armazenar um valor na memória, você deve atribuí-lo, usando o sinal = ou &lt;-. x = 1 print(x) ## [1] 1 y &lt;- 1+1 y ## [1] 2 texto = &quot;Esse é um texto. Observe as aspas duplas&quot; assim = &#39;Também podem ser usadas aspas simples&#39; sugestao = &#39;Use aspas simples sempre que &quot;possível&quot; para delimitar a variável. Os textos em português costumam usadas aspas duplas.&#39; print(sugestao) ## [1] &quot;Use aspas simples sempre que \\&quot;possível\\&quot; para delimitar a variável. Os \\ntextos em português costumam usadas aspas duplas.&quot; writeLines(sugestao) ## Use aspas simples sempre que &quot;possível&quot; para delimitar a variável. Os ## textos em português costumam usadas aspas duplas. 3.1 Numéricas numero1 = 1 class(numero1) ## [1] &quot;numeric&quot; typeof(numero1) ## [1] &quot;double&quot; numero2 = 2L class(numero2) ## [1] &quot;integer&quot; typeof(numero2) ## [1] &quot;integer&quot; O R não usa a formatação brasileira de números. No sistema adotado, devemos separar decimais por ponto, não por vírgulas. Por isso, o correto é 0.5 ao invés de 1,5. numero3 = 1.5 numero4 = 1.5 * 2 print(numero3) ## [1] 1.5 print(numero4) ## [1] 3 Operações matemáticas com objetos numéricos serão apresentadas na seção Funções numéricas básicas. 3.2 Textuais Para inserir um caractere, uma palavra ou uma frase, é necessário o uso de aspas simples ou duplas. Como no português é comum o uso de aspas duplas, é interessante o uso de aspas simples no R. Isso se deve ao fato de que se você precisar eventualmente incluir as aspas duplas, elas podem ficar dentro das aspas simples. Por exemplo, é aceitável: texto1 = &#39;Ela disse: &quot;Ok&quot;.&#39; texto2 = &#39;E eu respondi: &quot;Certo&quot;.&#39; writeLines(c(texto1, texto2)) ## Ela disse: &quot;Ok&quot;. ## E eu respondi: &quot;Certo&quot;. Perceba que as aspas simples estão funcionando apenas como delimitadores. Estão dizendo que tudo que está dentro delas faz parte de um mesmo texto, inclusive as aspas duplas. texto3 &lt;- &quot;Ela disse: &quot;Ok&quot;.&quot; O texto3 seria problemático para o R. Assim que ele identifica as primeiras aspas, ele passa a esperar um texto. Quando aparecem mais aspas, ele entende que o texto foi encerrado e não pretende continuar lendo o que vem depois. Com isso, ele estranha que tenha mais texto logo após (Ok.) 3.2.1 Numérica ou textual? O CNPJ de uma empresa é composto por 14 dígitos numéricos (0 a 9), separados por alguns marcadores (pontos, barras e traços). Por exemplo, pode ser 12.345.678/0001-19. Para guardar essa informação como uma variável numérica, você precisaria omitir as marcações, digitando 12345678000119. Entretanto, existe aqui um problema: o caso dos CNPJs iniciados por 0. Se há um 0 no início do número, ele é sempre ignorado. Por exemplo, 02 sempre será salvo na memória como 2, porque o zero à esquerda, na Matemática, não tem função. Pensando nisso, pode ser mais interessante salvar o CNPJ como uma variável textual. cnpj &lt;- &quot;12.345.678/0001-19&quot; Com isso não são perdidos os marcadores. Perceba, por fim, que o tratamento desse número como texto não tem implicações sobre a análise estatística dos dados. O CNPJ não é um número sobre o qual você realiza operações matemáticas. Você não calcula a média,a moda ou a mediana dos CNPJs e nem cria um gráfico de CNPJs. Ele é um identificador da empresa, tal qual o nome dela. No caso de pessoas físicas, o mesmo raciocínio vale para o CPF. Exceção: os dois últimos dígitos do CNPJ (e do CPF) são um código verificador. Alguns formulários cadastrais usam esses dois últimos dígitos para conferir se o campo foi preenchido corretamente. Essa conferência é feita a partir de um cálculo matemático; logo, há casos específicos em que mesmo o CNPJ pode ser usado para algum cálculo. 3.3 Lógicas Em muitos casos, é importante ter variáveis que indiquem TRUE (Verdadeiro) ou FALSE (Falso). Por exemplo, podemos querer verificar se cada entidade possui determinada característica (digamos, seu endividamento de curto prazo é menor que o Ativo Circulante); se a empresa tiver essa característica, receberá o valor TRUE; caso contrário, FALSE. O tipo de variável que admite apenas esses dois valores lógicos é chamado de Booleana (boolean ou bool). Nos estudos sobre lógica, frequentemente nos deparamos com Tabelas de Verdade e alguns operadores lógicos, dentre os quais os mais comuns são o AND (e) e o OR (ou). É preciso um pouco de atenção para usá-los corretamente. Se dizemos que estamos precisando de um relatório que contenha apenas as empresas que tiveram lucros no ano passado (2020) e que abriram capital nos últimos cinco anos (2016-2020), estamos exigindo que as empresas necessariamente atendam aos dois requisitos; ou seja, o relatório só deve conter as empresas que, além de terem aberto o capital entre 2016 e 2020, também apresentaram, em seus demonstrativos financeiros de 2020, um resultado contábil positivo. Com o uso do operador AND (e), não basta uma característica, é necessário que atenda as duas. Se tivéssemos dito que queríamos um relatório com empresas que têm Patrimônio Líquido Negativo ou que estão em Recuperação Judicial, precisaríamos pegar todas as empresas que atendem a qualquer um dos critérios (inclusive as que atendem a ambos os critérios). Assim, se a empresa tem PL negativo, mas não está em recuperação judicial, ela deve constar no relatório. Se ela está em recuperação judicial, mas não tem PL negativo, ela deve constar no relatório. Se ela tem PL negativo e está em recuperação judicial, ela também deve estar no relatório. A única situação em que ela deve ser deixada de fora é caso ela tenha PL maior ou igual a zero e não esteja em recuperação judicial. No R, o operador AND é representado por &amp; (e comercial), enquanto o OR é representado por | (uma barra vertical). # AND ou E é representado por &amp; print(TRUE &amp; FALSE) ## [1] FALSE # OR ou OU é representado por | print(TRUE | FALSE) ## [1] TRUE Além disso, é possível realizar a negação de um valor lógico. Dizer que algo não é verdadeiro equivale a dizer que é falso. Dizer que algo não é falso equivale a dizer que algo é verdadeiro. No R, a negação é representada por um ! (ponto de exclamação). # AND ou E é representado por &amp; 2 &lt; 5 ## [1] TRUE # OR ou OU é representado por | !(2 &lt; 5) ## [1] FALSE Sabemos que 2 é menor que 5. Por isso, a expressão 2 &lt; 5 retorna um valor TRUE (verdadeiro). Quando adicionamos o operador de negação (!), estamos pedindo para que o R retorne não verdadeiro, o que equivale a Falso. Variáveis lógicas podem ter muitos usos, como parâmetros em funções ou filtros para listas de dados. Por exemplo, você pode querer que o usuário informe se ele quer imprimir o relatório dos valores ao final. Nesse caso, ele deveria informar que o valor do parâmetro imprimir_relatorio deveria ser TRUE. Caso ele não queira imprimir o relatório, deveria informar imprimir_relatorio como FALSE. Também podem ser usados para comparações de igualdade (==) ou desigualdade (!=). dois_numero &lt;- 2 dois_texto &lt;- &quot;dois&quot; # Vamos testar de o numero dois é o mesmo que o dois &quot;por extenso&quot; dois_numero == dois_texto ## [1] FALSE # Vamos testar de o numero dois é diferente do dois &quot;por extenso&quot; dois_numero != dois_texto ## [1] TRUE O R não entende que dois é a forma por extenso do número 2. Para o R, há um número 2 e há uma palavra, cujo significado o R desconhece. Então, na comparação entre esse inteiro e essa string, o R entende que há uma diferença (de tipos). Por isso, ele afirma que são diferentes (ou não iguais). dois_numero &lt;- 2 dois_texto &lt;- &quot;2&quot; # Vamos testar de o numero dois é o mesmo que o dois &quot;caractere&quot; # O resultado é verdadeiro porque apesar dos tipos serem diferentes, o conteúdo é o mesmo. dois_numero == dois_texto ## [1] TRUE Existe outro operador de igualdade (===), mas que não será tratado agora. 3.4 Datas today &lt;- Sys.Date() print(today) ## [1] &quot;2022-03-21&quot; today &lt;- format(today, &quot;%d/%m/%Y&quot;) print(today) ## [1] &quot;21/03/2022&quot; today2 &lt;- format(Sys.Date(), &quot;%d/%m/%Y&quot;) print(today2) ## [1] &quot;21/03/2022&quot; 3.5 Exercício Construa uma tabela verdade para as operações lógicas E, OU. v1 v2 Operador E True True TRUE True False FALSE False True FALSE False False FALSE v1 v2 Operador OU True True TRUE True False TRUE False True TRUE False False FALSE "],["agrupamentos-de-dados.html", "4 Agrupamentos de Dados 4.1 Vetores 4.2 Matrizes 4.3 Data frames 4.4 Tibbles 4.5 Array 4.6 Listas 4.7 Factors", " 4 Agrupamentos de Dados Pode ser desejável juntar vários valores em um único objeto gravado na memória usada pelo R. Por exemplo, você pode querer criar um objeto que contenha o nome das empresas que tiveram as maiores ofertas públicas iniciais na bolsa de valores brasileira em 2020; ou você pode querer a relação dos nomes e dos valores. Dependendo dos tipos de dados envolvidos, a forma de fazer isso pode mudar. 4.1 Vetores Quando a sua relação trata de apenas um conjunto de valores de mesmo tipo (todos numéricos, todos textuais ou todos lógicos), pode ser formada como um vetor. Por exemplo, poderia haver um vetor com o nome dos CEOs das empresas do setor bancário; ou um vetor com o salário desses CEOs. Entretanto, se estivéssemos falando de uma relação envolvendo os nomes e os salários, seria inadequado usarmos o vetor, porque agora teríamos duas dimensões, além de dois tipos: uma mesma pessoa (o CEO) possui duas características: o nome (textual / string) e o salário (numérica / num). A criação de vetores é feita com o uso do c( ), em que os valores que devem ser atribuídos ao vetor são incluídos dentro dos parênteses e separados por vírgula. vetorNumerico = c(1,2,3,4,5) vetorLogico = c(TRUE, TRUE, FALSE,FALSE) vetorTextual = c(&quot;Eu&quot;, &quot;Nasci&quot;, &quot;há&quot;, &quot;10.000&quot;, &quot;anos&quot;, &quot;atrás&quot;) Note que todos os vetores foram criados com dados de mesmo tipo. O vetor numérico tem apenas números inteiros (1 a 5); o vetor lógico tem apenas Verdadeiro (TRUE) e Falso (FALSE); o vetor de texto tem apenas elementos textuais (mesmo o número está entre aspas, o que força que aqueles dígitos sejam lidos como texto). Caso você tente misturar tipos, o R irá forçar a padronização. Por exemplo, o que aconteceria se você tentasse criar um vetor com números e textos? vetorNumTex = c(1,2,&quot;três&quot;,&quot;4&quot;,5) print(vetorNumTex) ## [1] &quot;1&quot; &quot;2&quot; &quot;três&quot; &quot;4&quot; &quot;5&quot; Todos os elementos apresentados estão entre aspas. Como o R não tem uma forma de transformar três em um número, ele converte todos os outros números em texto. Por isso, 1 vira 1, 2 vira 2 e 5 vira 5. Teste no seu console a seguinte operação: 3 + 1 O R informará um erro. 3 não é um número, mas um texto (por causa das aspas). Não é possível somar um texto com um número. É o mesmo que você tentar somar banana com 97. Não dá. 4.2 Matrizes A matriz é um conjunto de dados do mesmo tipo, ordenados em linhas (filas horizontais) e colunas (filas verticais). É criada pelo matrix(), devendo ser informados os dados que irão compor a matriz (normalmente dispostos em um vetor), o número de linhas (nrow), o número de colunas (ncol) e se o preenchimento deve ser feito por linha (byrow = TRUE) ou por coluna (byrow = FALSE). # Se a matriz dos inteiros de 1 a 6, dispostos em 3 linhas e 2 colunas, preenchida pela ordem das linhas. mat = matrix(c(1:6), nrow = 3, ncol = 2, byrow = TRUE) print(mat) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 Ou seja, os números foram distribuídos até o fim da primeira linha, depois até o fim da segunda linha e depois até o fim da terceira (e última) linha. # Se a matriz dos inteiros de 1 a 6, dispostos em 3 linhas e 2 colunas, preenchida pela ordem das colunas mat = matrix(c(1:6), nrow = 3, ncol = 2, byrow = FALSE) print(mat) ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 Em contraste, aqui o preenchimento foi por colunas. Foi preenchida toda a primeira coluna e depois toda a segunda coluna. Se já tivéssemos um vetor salvo na memória, poderíamos usá-lo para compor a matriz. vetorParaMatriz &lt;- c(&quot;eu&quot;, &quot;nasci&quot;, &quot;há&quot;, &quot;dez mil&quot;, &quot;anos&quot;, &quot;atrás&quot;) mat = matrix(vetorParaMatriz, nrow = 3, ncol = 2, byrow = TRUE) print(mat) ## [,1] [,2] ## [1,] &quot;eu&quot; &quot;nasci&quot; ## [2,] &quot;há&quot; &quot;dez mil&quot; ## [3,] &quot;anos&quot; &quot;atrás&quot; Você reparou que aparecem valores entre colchetes e separados por vírgulas? Eles indicam a posição na matriz. [m,n] Posição Elementos [1,] Primeira Linha eu, nasci [2,] Segunda Linha há,dez mil [,1] Primeira Coluna eu, há, anos [,2] Segunda Coluna nasci,dez mil, atrás [1,1] Primeira Linha, Primeira Coluna eu [1,2] Primeira Linha, Segunda Coluna nasci [2,1] Segunda Linha, Primeira Coluna há [2,2] Segunda Linha, Segunda Coluna dez mil Eventualmente, pode ser interessante informar os nomes para as linhas e para as colunas. Por exemplo, se você estiver precisando mapear a distância entre as unidades de uma empresa, seria importante dizer quais são as filiais. vetorFiliais &lt;- c(&quot;Natal&quot;, &quot;Parnamirim&quot;, &quot;Macaíba&quot;) vetorDistancias &lt;- c(0, 10, 12, 10, 0, 2, 12, 2, 0) Por isso, vamos incluir o argumento dimnames = list(row_names, col_names) dimnames significa nome das dimensões, que é informado por meio de dois vetores: o vetor com o nomes das linhas (row_names) e o vetor com o nome das colunas (col_names). No nosso exemplo, as linhas e as colunas devem possuir os mesmos nomes (porque queremos estabelecer uma matriz com a distância entre cada unidade da empresa). Por isso, trocaremos row_names por vetorFiliais e também trocaremos col_names por vetorFiliais. distanciaFiliais = matrix(vetorDistancias, nrow = 3, ncol = 3, byrow = TRUE, dimnames = list(vetorFiliais, vetorFiliais)) distanciaFiliais ## Natal Parnamirim Macaíba ## Natal 0 10 12 ## Parnamirim 10 0 2 ## Macaíba 12 2 0 Por que o elemento [1,1] da matriz foi 0? A distância de uma unidade para ela mesmo, por definição, é zero. Para solicitar a distância entre a filial Natal e a filial Parnamirim: distanciaFiliais[&quot;Natal&quot;, &quot;Parnamirim&quot;] ## [1] 10 Perceba que, nessa matriz, a distância entre Natal - Parnamirim é a mesma que Parnamirim - Natal. Se pensarmos em termos de rodovias, isso pode não ser necessariamente verdade, pois em casos específicos pode ser necessário um deslocamento adicional em um dos sentidos (por exemplo, ir adiante x quilômetros para conseguir fazer um retorno). No caso dessa matriz, solicitar o valor como: distanciaFiliais[Natal, Parnamirim] ou distanciaFiliais[Parnamirim, Natal] produziria o mesmo resultado e, nesse caso, é irrelevante. Entretanto, é importante ter em mente que isso nem sempre será verdade. Além disso, se quiséssemos saber a distância da filial Natal para todas as demais, deveríamos informar apenas a linha, omitindo a informação após a vírgula. distanciaFiliais[&quot;Natal&quot;,] ## Natal Parnamirim Macaíba ## 0 10 12 Alternativamente, sabendo que Natal é a primeira linha da matriz, também seria possível executar distanciaFiliais[1,] ## Natal Parnamirim Macaíba ## 0 10 12 A segunda opção é particularmente importante quando as filas (linhas ou colunas) não estão nomeadas. 4.3 Data frames O data frame é similar a matrix, mas admite colunas com tipos diferentes. Nesse caso, é possível incluir uma coluna para o nome de uma empresa (string), uma coluna para o CNPJ (string), uma coluna para o número de empregados (integer), uma coluna para o faturamento (float) e uma coluna para identificar se as demonstrações já foram encerradas ou se ainda estão pendentes (boolean). O data frame é criado por meio do data.frame(), onde são passados os valores que irão entrar na estrutura. Uma possibilidade é passarmos vetores que representem as colunas. Assim, usaríamos um vetor para a empresa, um vetor para o CNPJ, um vetor para os empregados e um vetor para o faturamento. Não é necessário informar a quantidade de linhas ou colunas, já que o R não precisará organizar os dados (no caso da matriz, foi necessário informar como ela deveria ser preenchida). Os vetores serão incluídos como colunas na mesma ordem em que forem aparecendo dentro do data.frame(). # Ainda discutiremos o que são factors, mas por enquanto insiram esse argumento. clientes &lt;- data.frame(empresa = c(&quot;Marte S.A.&quot;, &quot;Deimos S.A.&quot;, &quot;Phobos S.A.&quot;), cnpj = c(&quot;00.000.001/0001-00&quot;,&quot;00.000.011/0001-10&quot;, &quot;99.000.001/0001-55&quot;), empregados = c(10,20, 25), encerramento = c(FALSE, FALSE, TRUE), stringsAsFactors = FALSE) clientes ## empresa cnpj empregados encerramento ## 1 Marte S.A. 00.000.001/0001-00 10 FALSE ## 2 Deimos S.A. 00.000.011/0001-10 20 FALSE ## 3 Phobos S.A. 99.000.001/0001-55 25 TRUE Por conta dessa permissão para uso de tipos diferentes em uma mesma estrutura, os data frames são consideravalmente importantes. Para solicitar uma fila específica (linha ou coluna) ou um elemento, é possível usar a mesma notação das matrizes. clientes[1,] ## empresa cnpj empregados encerramento ## 1 Marte S.A. 00.000.001/0001-00 10 FALSE # para gerar uma relação com os CNPJs: clientes[,2] ## [1] &quot;00.000.001/0001-00&quot; &quot;00.000.011/0001-10&quot; &quot;99.000.001/0001-55&quot; Da mesma forma que fizemos com as matrizes, podemos solicitar uma coluna com base em seu nome. clientes[,&quot;cnpj&quot;] ## [1] &quot;00.000.001/0001-00&quot; &quot;00.000.011/0001-10&quot; &quot;99.000.001/0001-55&quot; Percebea que nesse caso as linhas não foram nomeadas. No caso dos data frames, é bem comum que o identificador seja inserido como um dado O data frame ainda admite uma forma adicional de solicitar uma coluna, informando o nome do objeto seguido do cifrão ($) e do nome da coluna. clientes$cnpj ## [1] &quot;00.000.001/0001-00&quot; &quot;00.000.011/0001-10&quot; &quot;99.000.001/0001-55&quot; Perceba como a notação do R evolui. Quando resolvemos solicitar um clientes$cnpj, estamos usando um procedimento equivalente a clientes[,cnpj]. Como poderíamos fazer para usando a notação com cifrão, solicitar o terceiro elemento dessa relação? clientes$cnpj[3] ## [1] &quot;99.000.001/0001-55&quot; Não precisamos informar dois elementos dentro dos colchetes [,] porque um deles foi informado anteriormente (no caso, a coluna cnpj)! Assim, quando informarmos o [3] estamos automaticamente nos referindo à linha. 4.4 Tibbles O tibble é um tipo especial de data.frame, que realiza algumas operações de forma ligeiramente diferente que o data.frame convencional. Eles fazem menos e reclamam mais, induzindo o programador a tratar melhor certos aspectos do código. Essencialmente: não permitem referências parciais ao nome de variáveis contidas em um data.frame; são mais fiéis ao que se espera que as variáveis serão (em várias ocasiões, não produzem factors, ao invés de chars) e avisam se uma coluna que está sendo requerida não faz parte do banco de dados. Para mais detalhes, acesse a documentação: &lt; https://tibble.tidyverse.org/ &gt;. Como o tibble não é uma estrutura nativa do R, deve ser acessada por meio do pacote tibble. # chamando o pacote tibble library(tibble) primeiroTibble &lt;- tibble(nome = c(&quot;raimundo&quot;, &quot;marciano&quot;), numeros = c(29,12)) primeiroDataFrame &lt;- data.frame(nome = c(&quot;raimundo&quot;, &quot;marciano&quot;), numeros = c(29,12)) primeiroTibble ## # A tibble: 2 x 2 ## nome numeros ## &lt;chr&gt; &lt;dbl&gt; ## 1 raimundo 29 ## 2 marciano 12 primeiroDataFrame ## nome numeros ## 1 raimundo 29 ## 2 marciano 12 str(primeiroDataFrame) ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ nome : chr &quot;raimundo&quot; &quot;marciano&quot; ## $ numeros: num 29 12 Perceba que o tibble exibido já indica os tipos das variáveis que o compõem. No caso do data frame, foi necessário solicitar, por meio do comando str(), essa informação. Além disso, o primeiroTibble tem um resultado mais previsível que o primeiroDataFrame: as variáveis textuais foram consideradas corretamente como no tibble, mas foram identificadas como no data frame, o que pode ser um comportamento não esperado. Para garantir que o data frame trate a primeira coluna como string, é necessário forçar esse comportamento, incluindo o parâmetro &lt;stringsAsFactors = F&gt;. segundoDataFrame &lt;- data.frame(nome = c(&quot;raimundo&quot;, &quot;marciano&quot;), numeros = c(29,12), stringsAsFactors = F) segundoDataFrame ## nome numeros ## 1 raimundo 29 ## 2 marciano 12 str(segundoDataFrame) ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ nome : chr &quot;raimundo&quot; &quot;marciano&quot; ## $ numeros: num 29 12 Agora temos um data.frame com os mesmos tipos de variáveis que o tibble. Em resumo, as diferenças são pequenas, mas o tibble é uma versão mais moderna, mais previsível e que gera mais alertas par ao programador que a está usando. A solicitação de partes do tibble é idêntica à do data.frame. #Para solicitar a colunha chamada de &#39;nome&#39; primeiroTibble[&#39;nome&#39;] ## # A tibble: 2 x 1 ## nome ## &lt;chr&gt; ## 1 raimundo ## 2 marciano #Para solicitar a segunda coluna primeiroTibble[,2] ## # A tibble: 2 x 1 ## numeros ## &lt;dbl&gt; ## 1 29 ## 2 12 A principal diferença é que o tibble não aceita referência parcial. Isso significa que poderíamos solicitar ao data.frame uma coluna informando apenas parte do nome dela, ao passo que o tibble exige o nome completo. # O data.frame contém uma coluna chamada &#39;nome&#39;. Veja o que acontece se, por descuido # pedirmos a coluna $nom (faltando o &#39;e&#39;) primeiroDataFrame$nom ## [1] &quot;raimundo&quot; &quot;marciano&quot; O data.frame retorna os dados normalmente, como se o nome estivesse completo. Isso pode ser indesejável caso haja ambiguidade nos títulos das variáveis. Por exemplo, poderia haver uma variável chamada nome e outra nomeCompleto. Com a informação incompleta, você não garante estar usando a variável correta. O tibble exige que você informe o nome exato do que está sendo solicitado. # Veja o que acontece se você pedir o nome incompleto de uma variável primeiroTibble$nom ## Warning: Unknown or uninitialised column: `nom`. ## NULL O R retorna um aviso que informa que não é possível identificar uma coluna chamada nom. O mesmo aconteceria se você solicitasse qualquer outro nome não presente no banco de dados, como # Aconteceria o mesmo se você usasse um nome &#39;nada a ver&#39; primeiroTibble$valhaMeDeus ## Warning: Unknown or uninitialised column: `valhaMeDeus`. ## NULL O retorno é NULL (nulo), porque não há uma coluna chamada valhaMeDeus. Não custa lembrar que ele também diferencia letras maiúsculas de minúsculas (diz-se, nesse caso, que ele é case sensitive). Suponha que tenhamos (estranhamente) chamado a variável de nUmErOs. Não adiantar solicitar numeros, porque seria uma grafia diferente da esperada. outroTibble &lt;- tibble(nome = c(&quot;raimundo&quot;, &quot;marciano&quot;), nUmErOs = c(29,12)) outroTibble$nUmErOs ## [1] 29 12 outroTibble$numeros ## Warning: Unknown or uninitialised column: `numeros`. ## NULL Por padrão, a exibição de um tibble é limitada a 10 colunas e a uma quantidade de colunas compatível com a tela, o que não acontece com o data.frame, que tenta exibir todas as colunas presentes no banco de dados. Essa característica é dispensável em bancos com poucas variáveis, mas é bastante interessante caso ele contenha algumas centenas, porque não gera um output ilegível (raramente será interessante visualizar simultaneamente centenas de colunas ao mesmo tempo). Caso queira exibir todas as colunas, bastar adicionar o parâmetro (width = Inf) dentro do print(). 4.5 Array Um array é uma extensão do conceito de vetor, que ganha atributos: quantidade de dimensões (pode ser maior que 2, ao contrário das matrizes) e essas dimensões podem receber nomes. Note que por ser uma extensão do conceito de vetor, o array não é exatamente um vetor! linhas = c(2019, 2020) colunas = c(&quot;ROA&quot;, &quot;ROE&quot;, &quot;Liquidez&quot;) dimensoes = c(&quot;Empresa A&quot;, &quot;Empresa B&quot;) array(c(0.30, 0.35, 0.32, 0.36, 1.08, 1.12, 0.40, 0.25, 0.45, 0.30, 0.99, 1.13), dim = c(2,3,2), dimnames = list(linhas,colunas,dimensoes)) ## , , Empresa A ## ## ROA ROE Liquidez ## 2019 0.30 0.32 1.08 ## 2020 0.35 0.36 1.12 ## ## , , Empresa B ## ## ROA ROE Liquidez ## 2019 0.40 0.45 0.99 ## 2020 0.25 0.30 1.13 Dessaa forma, criamos uma matriz para cada dimensão (empresa A ou B), contendo os respectivos valores de cada indicador (ROA, ROE e Liquidez) em cada ano (2019 e 2020). Uma apresentação alternativa seria um data frame com dados empilhados. linhas = c(2019, 2020, 2019, 2020) colunas = c(&quot;ROA&quot;, &quot;ROE&quot;, &quot;Liquidez&quot;) dimensoes = c(&quot;Empresa A&quot;, &quot;Empresa A&quot;, &quot;Empresa B&quot;, &quot;Empresa B&quot;) data.frame(Empresas = dimensoes, Anos = linhas, ROA = c(0.30, 0.35, 0.40, 0.25), ROE = c(0.32, 0.36,0.45, 0.30), Liquidez = c(1.08, 1.12,0.99, 1.13)) ## Empresas Anos ROA ROE Liquidez ## 1 Empresa A 2019 0.30 0.32 1.08 ## 2 Empresa A 2020 0.35 0.36 1.12 ## 3 Empresa B 2019 0.40 0.45 0.99 ## 4 Empresa B 2020 0.25 0.30 1.13 Note que esse data frame condensa as informações, em comparação ao array com 3 dimensões. Pesquisadores que desejam trabalhar com dados em painel geralmente recorrem a essa estratégia de organização dos dados. 4.6 Listas A lista é uma forma que podemos usar para criar estruturas mais complexas, quando precisamos, por exemplo de mais dimensões e com tipos diferentes de dados. identificador1 = c(&quot;matriz&quot;) dados1 = c(1,9,37) identificador2 = c(&quot;filial&quot;) dados2 = c(2, 18, 74) lista = list(identificador1, dados1, identificador2, dados2) lista ## [[1]] ## [1] &quot;matriz&quot; ## ## [[2]] ## [1] 1 9 37 ## ## [[3]] ## [1] &quot;filial&quot; ## ## [[4]] ## [1] 2 18 74 Eventualmente, pode ser necessário descaracterizar a lista. Com a função unlist, podemos converter a lista anteriormente utilizada em um vetor. Note que a lista possuía elementos string e numéricos, o que era admitido em uma lista, mas não em um vetor. unlist(lista) ## [1] &quot;matriz&quot; &quot;1&quot; &quot;9&quot; &quot;37&quot; &quot;filial&quot; &quot;2&quot; &quot;18&quot; &quot;74&quot; Como esperado, o vetor converte todos os elementos em strings (texto), já que ele não consegue transformar matriz em um número. Outro exemplo: lista2 = list(c(&quot;primeiro&quot;, &quot;segundo&quot;), matrix(1:9, ncol = 3)) names(lista2) &lt;- c(&quot;ordem&quot;, &quot;dados&quot;) lista2 ## $ordem ## [1] &quot;primeiro&quot; &quot;segundo&quot; ## ## $dados ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 O uso de nomes é opcional, mas facilita o manuseio dos dados posteriormente. 4.7 Factors O factor é um tipo especial de vetor, utilizado para variáveis categóricas, ou seja, qualidades ou atributos de algo que serão usadas em alguma análise. Assim, se você está desenvolvendo um estudo comparativo por setor econômico, pode ser uma ideia interessante incluir o setor econômico como um factor. Note que setores econômicos não possuem um critério específico de ordenação; normalmente esse tipo de análise não define que um setor é mais importante que outro, sendo apenas um critério de separação entre as empresas que pertencem a cada um. Por exemplo, se eu quero comparar que setores sofreram mais com a Covid19 durante o ano de 2020, eu devo identificar que empresas pertencem a cada setor e analisar o que aconteceu com elas. Não há, a priori, qualquer ordem entre eles. Note que isso é bem diferente de perguntas, feitas em questionários, com graus de comparação. Por exemplo, se perguntamos ao entrevistado se ele está pouco satisfeito, satisfeito ou muito satisfeito, a resposta tem níveis. É claro que muito satisfeito possui um valor maior que satisfeito e é claro que satisfeito possui um valor maior que pouco satisfeito. O R não possui um mecanismo interno para entender expressões textuais, de forma que o programador precisa explicar para o R que certas strings possuem valor superior a outras. É fácil para um ser humano entender que excelente é melhor que bom, mas como o R não sabe o que significa nem bom, nem excelente, podemos criar um factor. vetor = c(&quot;bom&quot;, &quot;bom&quot;, &quot;excelente&quot;) fat = factor(vetor, levels = c(&quot;bom&quot;, &quot;excelente&quot;), ordered = TRUE) fat ## [1] bom bom excelente ## Levels: bom &lt; excelente fat[1] &lt; fat[3] ## [1] TRUE Várias funções de importações incluem um comando para que você informe qual tratamento deseja (geralmente o parâmetro é stringsAsFactors). "],["trabalhando-com-variáveis-no-r-base.html", "5 Trabalhando com variáveis no R Base 5.1 Manuseio de variáveis 5.2 Funções numéricas básicas 5.3 Funções textuais básicas", " 5 Trabalhando com variáveis no R Base 5.1 Manuseio de variáveis 5.2 Funções numéricas básicas As principais operações matemáticas e de estatísticas descritivas já vêm instaladas no R. # Sejam a = 5 e b = 2 e v um vetor de números inteiros a = 5 b = 2 v = c(1,2,3,4,5) As operações básicas podem ser representadas por: a + b # soma ## [1] 7 a - b # subtração ## [1] 3 a * b # multiplicação (asterisco) ## [1] 10 a / b # divisão ## [1] 2.5 a ^ b # potenciação (acento circunflexo) ## [1] 25 Além disso, podemos estabelecer as operações no vetor, aplicando a elementos específicos: v[1] + v[2] # soma ## [1] 3 v[1] - v[2] # subtração ## [1] -1 v[1] * v[2] # multiplicação (asterisco) ## [1] 2 v[1] / v[2] # divisão ## [1] 0.5 v[1] ^ v[2] # potenciação (acento circunflexo) ## [1] 1 Quando queremos aplicar ao vetor inteiro, podemos usar funções instaladas no R base. sum(v) # soma de todos os elementos de v ## [1] 15 sum(v[1:4]) # soma dos quatro primeiros elementos de v ## [1] 10 sum(v[3:5]) # soma dos três últimos elementos de v ## [1] 12 mean(v) # média aritmérica de todos os elementos de v ## [1] 3 mean(v[1:4]) # média dos quatro primeiros elementos de v ## [1] 2.5 5.3 Funções textuais básicas Seja o seguinte data.frame: cias &lt;- data.frame(nome = c(&quot;Petrobras&quot;, &quot;Petrobras&quot;, &quot;Vale&quot;, &quot;Banco do Brasil&quot;), ticker = c(&quot;PETR3&quot;, &quot;PETR4&quot;, &quot;VALE3&quot;, &quot;BBAS3&quot;), tipo = c(&quot;ON&quot;, &quot;PN&quot;, &quot;ON&quot;, &quot;ON&quot;), segmento = c(&quot;N2&quot;, &quot;N2&quot;, &quot;NM&quot;, &quot;NM&quot;), stringsAsFactors = FALSE) cias ## nome ticker tipo segmento ## 1 Petrobras PETR3 ON N2 ## 2 Petrobras PETR4 PN N2 ## 3 Vale VALE3 ON NM ## 4 Banco do Brasil BBAS3 ON NM Podemos estar interessados em saber se há uma empresa chamada Banco do Brasil. Para isso, há as funções grep() e grepl(). A grep() retorna um vetor com todas as posições em que foi encontrada a expressão desejada. A função grepl() retorna um vetor com a análise se cada elemento possui o padrão desejado ou não. Assim, se aplicássemos o grep() com a expressão Petrobras à lista de nomes, receberíamos a informação de que Petrobras foi localizada nas posições 1 e 2, sem qualquer menção às posições 3 e 4. Se usássemos o grepl(), o retorno seria uma lista composta por (TRUE, TRUE, FALSE, FALSE), que explicita a situação de cada observação. grep(&quot;Petrobras&quot;, cias$nome) ## [1] 1 2 grep(&quot;Banco do Brasil&quot;, cias$nome) ## [1] 4 grepl(&quot;Petrobras&quot;, cias$nome) ## [1] TRUE TRUE FALSE FALSE grepl(&quot;Banco do Brasil&quot;, cias$nome) ## [1] FALSE FALSE FALSE TRUE "],["criando-sua-própria-função.html", "6 Criando sua própria função 6.1 Modularização do código 6.2 Comentários", " 6 Criando sua própria função No R, você pode criar suas próprias funções da mesma forma como você cria e guarda dados: as funções também são objetos. A função para criar funções é a function(). Vamos começar com um caso simples, produzindo uma função que apenas imprime um texto básico. minhaFuncao &lt;- function(){ # Esta função imprime a mensagem &quot;Esta é a minha primeira função&quot; print(&quot;Esta é a minha primeira função.&quot;) } minhaFuncao() ## [1] &quot;Esta é a minha primeira função.&quot; Essa função ainda não aceita parâmetros, ou seja, ela ainda não é capaz de receber e processar dados. A função pode receber dados ou usar valores que estão presentes em variáveis anteriormente criadas. O argumento funciona como um apelido que será usado internamente para aquele valor. Por exemplo, posso querer que a função retorne quanto é 8% do salário do empregado. Assim, precisamos que a função receba o valor do salário empregado e que, a partir dele, calcule quanto é 8% e, por fim, exiba esse valor. # a funcao recebera o &#39;salario&#39; fgts &lt;- function(salario){ # variavei INTERNA fgtsFuncionario guarda o valor calculado do FGTS # ela não fica automaticamente disponível na memória do R após # a função ter terminado a execução fgtsFuncionario &lt;- salario * 0.08 # vamos gerar uma frase contendo o valor do FGTS mensagem &lt;- paste0(&quot;O valor do FGTS é R$ &quot;, fgtsFuncionario, &quot;.&quot;) # para imprimir a mensagem print(mensagem) # podemos encerrar o código da função especificando uma última variável INTERNA # que pode ser guardada em um objeto normal do R, por atribuição # Se essa atribuição não ocorrer, todos os valores gerados internamente # serão esquecidos fgtsFuncionario } Perceba que se simplesmente rodarmos a função sem guardar seu valor em um objeto fgts(2000) ## [1] &quot;O valor do FGTS é R$ 160.&quot; ## [1] 160 A mensagem será impressa, mas posteriormente não será possível resgatar nem o valor contido em \\(fgtsFuncionario\\) e nem em \\(mensagem\\). Se você quer que o R realmente guarde esses valores, e não apenas os exiba na tela, é necessário que haja a atribuição a uma variável. # estamos guardando o valor da execução de fgts(2000) em fgtsFunc1 fgtsFunc1 &lt;- fgts(2000) ## [1] &quot;O valor do FGTS é R$ 160.&quot; A função \\(fgts\\) foi encerrada com \\(fgtsFuncionario\\). Por isso, o valor que será atribuído para fgtsFunc1 será apenas \\(fgtsFuncionario\\). A \\(mensagem\\) não ficará gravada na memória. # se solicitarmos o valor de fgtsFunc1, será exibido o valor 160. fgtsFunc1 ## [1] 160 6.1 Modularização do código Em certas situações, seu script pode começar a ficar muito extenso, dificultando a leitura do código e que você encontre problemas específicos. Assim, pode ser uma boa ideia criar scripts auxiliares com funções. Você cria um script separado (por exemplo, funcoes.R) e deixa nele o código com as funções que serão utilizadas. No script onde você está desenvolvendo a análise, você inclui o comando source(), informando o parâmetro com a localização e o nome do arquivo (scripts/funcoes.R, por exemplo). # assumindo que o script auxiliar funcoes.R está na pasta scripts source(&quot;scripts/funcoes.R&quot;) O source() faz e leitura do script auxiliar e importa todas as funções que constam nele, de forma muito similar ao que é feito pelo library(). 6.2 Comentários "],["pacotes-bibliotecas.html", "7 Pacotes / Bibliotecas 7.1 clipr", " 7 Pacotes / Bibliotecas Muito do que precisamos usar já foi criado por alguém e disponibilizado na internet. No caso do R, a plataforma oficial para isso é o CRAN, mas há outras formas de conseguir esses códigos, como o Github. Diversas bibliotecas já vêm pré-instaladas no R. Quando precisamos instalar, usamos o comando install.packages() O nome do pacote deve ser informado entre aspas, como todo bom texto. install.packages(&quot;dplyr&quot;) A instalação do pacote dplyr permite o acesso a várias funções, como filter(), select() e group_by(). Quando um pacote é instalado, as funções ficam dentro dele. ISso significa que quando queremos acessá-las, precisamos identificar a fonte. dplyr::select() dplyr::filter() Em outras palavras, primeiro dizemos qual é o pacote (dplyr, no caso), seguido de \\(::\\) (dois pontos, duas vezes) e concluímos informando a função desejada e que se encontra desse pacote. Alternativamente, podemos usar library(dplyr). Isso deixa, durante a sessão ativa, as funções do pacote dplyr prontamente disponíveis. Quando você fechar o R (ou o R Studio), isso será desfeito. Portanto, da próxima vez que abrir o programa, precisará executar novamente o comando library(dplyr). É possível que existam duas funções com o mesmo nome, o que gera um conflito. Por exemplo, na minha máquina, há um pacote chamado stats que contém uma função chamada lag. Quando carrego o dplyr, que também possui uma função chamada lag(), recebo a seguinte mensagem: Attaching package: dplyr The following objects are masked from package:stats: filter, lag The following objects are masked from package:base: intersect, setdiff, setequal, union Isso significa que a função lag() do stats foi ocultada pelo dplyr. Em outras palavras, se eu for usar a função lag() sem dizer a que pacote ela pertence, o R automaticamente entenderá que eu estou usando a do dplyr, que está sendo dominante em relação ao stats. Sempre que você estiver confuso sobre qual função está dominando e qual está oculta, você pode incluir o nome do pacote no comando. Se você usar dplyr::lag(), com certeza será o lag() do dplyr. Se você usar stats::lag(), com certeza será o lag() do stats. Se o pacote que você deseja instalar está disponível no Github, você deve usar a função install_github() do pacote remotes. remotes::install_github() 7.1 clipr O pacote {clipr} permite a interação com o copia-e-cola do Windows. As duas principais funções são: clipr::read_clip_tbl() clipr::write_clip() A função read_clip_tbl() permite a leitura do que está copiado para dentro do R, na forma de um data.frame. A função write_clip permite copiar o conteúdo de um data.frame, que pode ser colado em uma planilha, como o Excel. Quando estamos trabalhando com a vírgula como separador de decimais, é importante incluir o argumento dec = , dentro dos parênteses. dados_colados_no_R = clipr::read_clip_tbl() dados_colados_no_R = clipr::read_clip_tbl(dec=,) clipr::write_clip(tabela_no_R) clipr::write_clip(tabela_no_R, dec=,) "],["obtendo-dados.html", "8 Obtendo dados 8.1 Planilhas (csv / Excel) 8.2 TXT (bloco de notas) e Word 8.3 XML 8.4 Dados coletados por meio de pacotes 8.5 Juntando bases", " 8 Obtendo dados O R oferece muitas opções de pacotes para importar os dados presentes em um arquivo. Além disso, alguns pacotes permitem que você colete dados de fontes oficiais facilmente. 8.1 Planilhas (csv / Excel) dados &lt;- read.csv(&quot;data/df_info.csv&quot;, encoding = &quot;UTF-8&quot;, colClasses = c(&quot;cnpj&quot; = &quot;character&quot;)) Solicitamos as cinco primeiras colunas das cinco primeiras linhas: dados[1:5, 1:5] ## name.company id.company cnpj ## 1 524 PARTICIPAÇOES SA 16284 1851771000155 ## 2 ADVANCED DIGITAL HEALTH MEDICINA PREVENTIVA S.A. 21725 10345009000198 ## 3 AES TIETÊ ENERGIA S.A 18970 4128563000110 ## 4 AFLUENTE TRANSMISSÃO DE ENERGIA ELETRICA S/A 22179 10338320000100 ## 5 ALEF SA 16705 2217319000107 ## date.registration date.constitution ## 1 1997-05-30 1997-04-02 ## 2 2009-06-24 2008-08-18 ## 3 2001-06-29 2000-11-06 ## 4 2010-09-24 2008-08-18 ## 5 1997-12-08 1997-10-06 O CNPJ está parecendo um pouco estranho. O nosso conhecimento prévio nos diz que todos os CNPJs possuem 14 dígitos. Uma simples inspeção visual revela que o número de caracteres parece estar diferente ao longo das linhas. Vamos ver se é verdade usando a função nchar(). nchar(dados$cnpj[1:5]) ## [1] 13 14 13 14 13 Isso significa que o CNPJ realmente está com um número diferente de caracteres: o primeiro tem 13 (errado); o segundo, 14 (certo); o terceiro, 13 (errado); e assim por diante. Não é interessante que deixemos nossos dados assim, então precisamos investigar o que está errado. Nosso conhecimento prévio também indica uma possível falha: vários CNPJs são iniciados com o dígito zero. Como a AES Tietê Energia S.A. está listada na bolsa de valores, é fácil achar seu CNPJ fazendo uma busca no Google: 04.128.563/0001-10. Com isso, temos uma evidência do problema e é interessante analisar mais alguns casos similares (o que, aliás, se confirma). Feito isso, precisamos saber se o problema está na importação ou no arquivo original que continha os dados. Como o arquivo é pequeno (menos de 100kb), é fácil inspecioná-lo, abrindo em uma planilha eletrônica convencional ou até mesmo no Bloco de Notas (foi a minha opção). Com isso, constatamos que os zeros do começo realmente estão faltando no arquivo e podemos concluir que não há erro na nossa importação. Entretanto, não significa que o dado está como queríamos, devendo ser tratado. Primeiro, vamos avaliar se há algum com menos de 13 dígitos. Afinal, não é porque nas primeiras cinco linhas o menor valor fio 13 que isso seja representativo de todo o conjunto, podendo haver algum CNPJ iniciado por 00, por exemplo. caracteres &lt;- nchar(dados$cnpj) table(caracteres) ## caracteres ## 3 9 10 11 12 13 14 ## 1 1 1 1 10 117 199 Logo, há um ou mais CNPJs em que o primeiro dígito diferente de 0 é o 12º. Assim, precisaremos preencher com zeros até termos 14 dígitos. zeros &lt;- NA for (i in 1:nrow(dados)){ numeroZeros &lt;- 14 - nchar(dados$cnpj[i]) if(numeroZeros == 0){ next } else { zeros &lt;- rep(&quot;0&quot;, numeroZeros) zeros &lt;- paste0(zeros, collapse = &quot;&quot;) dados$cnpj[i] &lt;- paste0(zeros, dados$cnpj[i], collapse = &quot;&quot;) } } # Vamos atualizar o vetor de caracteres caracteres &lt;- nchar(dados$cnpj) # E solicitar a frequência table(caracteres) ## caracteres ## 14 ## 330 8.2 TXT (bloco de notas) e Word 8.3 XML 8.4 Dados coletados por meio de pacotes 8.4.1 GetDFPData 8.4.2 BCBData 8.5 Juntando bases "],["exportando.html", "9 Exportando 9.1 Markdown", " 9 Exportando Uma forma interessante de fazer relatórios é a combinação entre a simplicidade do Markdown e o poder do R. O Markdown é um estilo fácil de marcação. Quando estamos usando um arquivo do tipo. Rmd (R Markdown) assinalamos certos blocos com caracteres especiais, de forma a indicar o que eles representam e como queremos que eles sejam formatados ou interpretados. Assim, se incluímos um trecho entre pares de asteriscos, queremos que esteja em negrito; mas se for antecedido por uma cerquilha (jogo da velha), trata-se do título da seção, devendo estar em negrito e com tamanho de fonte superior ao do corpo do texto. É possível, inclusive, combinar com o \\(\\LaTeX\\), o que facilita consideravelmente aa inserção de equações. 9.1 Markdown O Markdown possui um cabeçalho configurável, o Yaml. (Xie, Dervieux, and Riederer 2021) References "],["references.html", "References", " References "],["exemplos-de-contabilidade.html", "10 Exemplos de Contabilidade 10.1 Diário Contábil e Balancete", " 10 Exemplos de Contabilidade 10.1 Diário Contábil e Balancete # O pacote dplyr permite tratamentos de dados e o uso do pipe %&gt;% library(dplyr) Criemos um data frame chamado diario. diario = data.frame(matrix(ncol = 4, nrow = 0)) colnames(diario) &lt;- c(&quot;tipo&quot;, &quot;conta&quot;, &quot;valor&quot;, &quot;historico&quot;) Perceba que até agora não há qualquer dado dentro do data frame. A matrix inserida possui 4 colunas, mas nenhuma linha. print(diario) ## [1] tipo conta valor historico ## &lt;0 rows&gt; (or 0-length row.names) Essencialmente, a matriz só serviu para fixar a estrutura do data frame (4 colunas). Agora, precisamos criar uma função para registrar os lançamentos. Normalmente, um software contábil possui uma interface (uma parte visual) onde você seleciona as contas do plano de contas e registra os valores e o histórico. Aqui, vamos apenas passar as informações necessárias para uma função, que irá adicionar o lançamento ao diário. lancamento &lt;- function(tipo, conta, valor, historico = &quot;.&quot;){ temp &lt;- data.frame(tipo, conta, valor, historico) rbind(diario, temp) } A função lancamento exige os argumentos: i) tipo: é um débito (d) ou crédito (c); ii) conta: o nome da conta; iii) valor: o valor do lançamento (o decimal é o ponto, não a vírgula); iv) histórico: opcional. Note que para um lançamento completo é necessário executar a função pelo menos duas vezes, a fim de haver pelo menos um débito e pelo menos um crédito. Alguns lançamentos: diario &lt;- lancamento(&quot;d&quot;, &quot;Capital a Integralizar&quot;, 10000, &quot;Subscrição de Capital&quot;) diario &lt;- lancamento(&quot;c&quot;, &quot;Capital Social&quot;, 10000, &quot;Subscrição de Capital&quot;) diario &lt;- lancamento(&quot;d&quot;, &quot;Caixa&quot;, 10000, &quot;Integralização de Capital&quot;) diario &lt;- lancamento(&quot;c&quot;, &quot;Capital a Integralizar&quot;, 10000, &quot;Integralização de Capital&quot;) imprimeDiario &lt;-function(){ print(diario) } imprimeDiario() ## tipo conta valor historico ## 1 d Capital a Integralizar 10000 Subscrição de Capital ## 2 c Capital Social 10000 Subscrição de Capital ## 3 d Caixa 10000 Integralização de Capital ## 4 c Capital a Integralizar 10000 Integralização de Capital conferidor &lt;- function(){ temp = diario %&gt;% select(tipo, valor) %&gt;% group_by(tipo) %&gt;% summarise(Soma = sum(valor)) print(paste0(Créditos: temp\\(Soma[1])) print(paste0(&quot;Débitos: &quot;, temp\\)Soma[2])) } conferidor() planoContas &lt;- data.frame(categoria = c(A, A, E, E, E), conta = c(Ativo Total, Caixa, Patrimônio Líquido, Capital Social, Capital a Integralizar), natureza = c(d, d, c, c, c) ) balancete &lt;- planoContas levantaBalancete &lt;- function(){ temp &lt;- diario temp &lt;- left_join(temp, planoContas, all.x = TRUE, all.y = FALSE) temp\\(valor &lt;- ifelse (temp\\)tipo == temp\\(natureza, temp\\)valor1, temp$valor-1) temp &lt;- temp %&gt;% group_by(conta) %&gt;% summarise(valor = sum(valor)) temp } levantaBalancete() "]]
